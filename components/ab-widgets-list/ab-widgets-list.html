<polymer-element name="ab-widgets-list" on-dragstart="{{_widgetDragStart}}">
  <template>

    <style type="text/css">

      :host {
        display: block;
      }

      #searchInput {
        width: 100%;
        margin: 10px 0;
        height: 30px;
        border-radius: 5px;
        border: none;
        padding: 0px 5px;
      }

      polyfill-next-selector { content: ':host > ab-widget-item'; }
      ::content > ab-widget-item {
        cursor: pointer;
        display: none;
        padding: 5px 5px;
        margin-bottom: 5px;
        background-color: #fefefe;
        font-weight: bold;
        border-radius: 5px;
      }

      polyfill-next-selector { content: ':host > ab-widget-item:hover'; }
      ::content > ab-widget-item:hover {
        background-color: #BDD6EA;
      }

      polyfill-next-selector { content: ':host > ab-widget-item.visible'; }
      ::content > .visible {
        display: block !important;
      }


    </style>
    <input type="text" id="searchInput" list="widgets" value="{{filter}}" placeholder="Filter widgets..."/>
    <datalist id="widgets">
      <template repeat="{{widgets}}">
        <option value="{{tag}}">{{name}}</option>
      </template>
    </datalist>
    <content id="items" select="ab-widget-item"></content>
    <template if="{{!hasVisibleWidgets}}">
      <span>No widget matching search :(</span>
    </template>
  </template>
  <script>
    Polymer('ab-widgets-list', {

      search: '',
      hasVisibleWidgets: true,

      ready: function() {
        this._updateAutocomplete();
        this._updateWidgetItems();
        this._watchMutations();
      },

      filterChanged: function(filter) {
        this._updateWidgetItems();
      },

      _updateWidgetItems: function() {
        var self = this;
        var filter = this.filter;
        var items = this._getWidgetItems();
        this.hasVisibleWidgets = false;
        items.forEach(function(item) {
          var name = item.getAttribute('name');
          if(!filter || name.toLowerCase().indexOf(filter.toLowerCase()) !== -1) {
            item.classList.add('visible');
            self.hasVisibleWidgets = true;
          } else {
            item.classList.remove('visible');
          }
        });
      },

      _getWidgetItems: function() {
        var slice = Array.prototype.slice;
        var elements = this.$.items.getDistributedNodes();
        return slice.call(elements);
      },

      _watchMutations: function() {
        var observer = new MutationObserver(this._updateAutocomplete.bind(this));
        var config = {childList: true};
        observer.observe(this, config);
      },

      _updateAutocomplete: function() {
        this.widgets = this._getWidgetItems().map(function(el) {
          return {
            name: el.getAttribute('name'),
            tag: el.getAttribute('tag')
          };
        });
      },

      _widgetDragStart: function(evt) {
        var dataTransfer = evt.dataTransfer;
        dataTransfer.effectAllowed = 'copy';
        dataTransfer.setData('application/x-ab-widget', evt.target.tag);
      }

    });
  </script>
</polymer-element>

<polymer-element name="ab-widget-item" attributes="name tag" draggable="true">
  <template>
    <style>

      :host {
        display: block;
      }

    </style>
    <span>{{name}}</span>
  </template>
  <script>
    Polymer('ab-widget-item', {

    });
  </script>
</polymer-element>