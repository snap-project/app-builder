<link rel="import" href="../ab-widget/index.html">
<polymer-element name="ab-container" attributes="layout">
  <template>
    <style>

      :host {
        display: block;
      }

      :host > ab-widget > #panels > #viewPane > #content > * {
        display: inline-block;
        vertical-align: text-top;
      }

      :host > ab-widget > #panels > #viewPane > #content > #placeholder {
        text-align: center;
        display: block;
      }

      :host #content > * {
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
      }

      :host[layout="horizontal"] > ab-widget > #panels > #viewPane > #content > * {
        display: inline-block;
        vertical-align: text-top;
      }

      :host[layout="vertical"] > ab-widget > #panels > #viewPane > #content > * {
        width: 100%;
      }

    </style>
    <ab-widget id="widget" name="Container">
      <div id="content" class="view">
        <h3 id="placeholder">Add widgets here</h3>
        <content></content>
      </div>
      <div class="edit">
        <div>
          <label>Layout</label>
          <select value="{{layout}}">
            <option value="horizontal">Horizontal</option>
            <option value="vertical">Vertical</option>
          </select>
        </div>
        <div>
          <label>Gutter</label>
          <input type="number" value="{{gutter}}" min="0" max="99">%
        </div>
      </div>
    </ab-widget>
  </template>
  <script>
    (function() {

      var filter = Array.prototype.filter;
      var reduce = Array.prototype.reduce;

      Polymer('ab-container', {

        gutter: 1,
        layout: 'horizontal',

        ready: function() {
          this.watchMutations();
          this.applyLayout = this.debounce(this.applyLayout, 250);
          this.applyLayout();
        },

        optionsChanged: function(oldOpts, newOpts) {
          if(newOpts) {
            if('gutter' in newOpts) {
              this.gutter = newOpts.gutter;
            }
            if('layout' in newOpts) {
              this.layout = newOpts.layout;
            }
            this.applyLayout();
          }
        },

        layoutChanged: function() {
          this.applyLayout();
        },

        gutterChanged: function() {
          this.applyLayout();
        },

        applyLayout: function() {
          var self = this;
          var nodes = this.querySelectorAll('.view > *');
          nodes = filter.call(nodes, function(n) {
            return n.parentElement === self;
          });
          var count = nodes.length;
          var percent = 100-((count-1)*this.gutter);
          var width = (percent/count) + '%';
          while(count--) {
            el = nodes[count];
            if(this.layout === 'horizontal') {
              el.style.width = width;
              if(count !== nodes.length-1) {
                el.style.marginRight = this.gutter + '%';
              } else {
                el.style.marginRight = 0;
              }
            } else {
              el.removeAttribute('style');
              if(count !== nodes.length-1) {
                el.style.marginBottom = this.gutter + '%';
              } else {
                el.style.marginBottom = 0;
              }
            }
          }
        },

        exports: function() {
          var options = {
            gutter: this.gutter,
            layout: this.layout
          };
          return options;
        },

        getWidgetsTree: function() {
          var tree = {};
          tree.type = this.tagName;
          tree.options = this.exports();
          tree.children = reduce.call(this.children, function(arr, el) {
            var exports;
            if(typeof el.getWidgetsTree === 'function') {
              exports = el.getWidgetsTree();
            } else if(typeof el.exports === 'function') {
              exports = {
                type: el.tagName,
                options: el.exports(),
              };
            }
            if(exports) {
              arr.push(exports);
            }
            return arr;
          }, []);
          return tree;
        },

        togglePlaceholderAndUpdate: function() {
          var count = this.children.length;
          this.$.placeholder.style.display = count > 0 ? 'none' : 'block';
          this.applyLayout();
        },

        watchMutations: function() {
          var self = this;
          // create an observer instance
          var observer = new MutationObserver(this.togglePlaceholderAndUpdate.bind(this));
          // configuration of the observer:
          var config = { childList: true };
          // pass in the target node, as well as the observer options
          observer.observe(this, config);
        },

        debounce: function(func, wait, immediate) {
          var self = this;
          var timeout;
          return function() {
            var args = arguments;
            var later = function() {
              timeout = null;
              if (!immediate) func.apply(self, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(self, args);
          };
        }

      });

    }());
  </script>
</polymer-element>