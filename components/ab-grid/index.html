<polymer-element name="ab-grid" attributes="columns rows"
  on-mousedown="{{_startResizing}}" on-mouseup="{{_stopResizing}}"
  on-mousemove="{{_resize}}" on-mouseleave="{{_stopResizing}}">
  <template>
    <link rel="stylesheet" type="text/css" href="style.css">
    <content id="content" select="*"></content>
    <div id="placeholder"></div>
  </template>
  <script>
    (function() {

      var slice = Array.prototype.slice;

      var prefixes = ['moz', 'o', 'webkit', 'ms', ''];

      function _translate(el, xOffset, yOffset) {
        var transform = 'translateX(' + xOffset + 'px) translateY(' + yOffset + 'px)';
        prefixes.forEach(function(prefix) {
          el.style['-' + prefix + '-transform'] = transform;
        });
        el.style.transform = transform;
      }

      // Grid logic

      var GridLayout = function(columns, rows) {
        this._counter = 0;
        this.columns = columns;
        this.rows = rows;
        this._cells = {};
      };

      var p = GridLayout.prototype;

      p.getElementInCell = function(row, column) {
        return this._cells[row + '-' + column];
      };

      p.getElementsInRect = function(top, left, width, height) {
        var elements = [];
        var id;
        for(var column = left; column < left+width; ++column) {
          for(var row = top; row < top+height; ++row) {
            id = this.getElementInCell(row, column);
            if(id && elements.indexOf(id) === -1) {
              elements.push(id);
            }
            id = null;
          }
        }
        return elements;
      };

      p.isFilled = function(row, column) {
        return (row + '-' + column) in this._cells;
      };

      p.fill = function(id, top, left, width, height) {
        for(var column = left; column < left+width; ++column) {
          for(var row = top; row < top+height; ++row) {
            this._cells[row + '-' + column] = id;
          }
        }
      };

      p.unfill = function(top, left, width, height) {
        width = width || 1;
        height = height || 1;
        for(var column = left; column < left+width; ++column) {
          for(var row = top; row < top+height; ++row) {
            delete this._cells[row + '-' + column];
          }
        }
      };

      p.isSpaceAvailable = function(top, left, width, height) {
        if(top < 0 || left < 0) {
          return false;
        }
        for(var column = left; column < left+width; ++column) {
          for(var row = top; row < top+height; ++row) {
            if(column > this.columns || this.isFilled(row, column)) {
              return false;
            }
          }
        }
        return true;
      };

      p.getAvailableInsertionPoint = function(width, height) {
        var isSpaceAvailable;
        for(var top = 0, rows = this.rows; top < rows; ++top) {
          for(var left = 0, columns = this.columns; left < columns; ++left) {
            isSpaceAvailable = this.isSpaceAvailable(top, left, width, height);
            if(isSpaceAvailable) {
              return {left: left, top: top};
            }
          }
        }
      };

      p.insert = function(element, rect) {
        var id = this.getElementId(element);
        if(!id) {
          id = this.registerElement(element);
        }
        if(rect && rect.top && rect.left) {
          this.fill(id, rect.top, rect.left, rect.width || 1, rect.height || 1);
        } else {
          var pos = this.getAvailableInsertionPoint(rect.width || 1, rect.height || 1);
          this.fill(id, pos.top, pos.left, rect.width || 1, rect.height || 1);
        }
      };

      p.resize = function(id, toWidth, toHeight) {
        var self = this;
        var rect = self.getElementRect(id);
        var collisions = self.getElementsInRect(rect.top, rect.left, toWidth, toHeight);
        collisions.forEach(function(collId) {
          if(id !== collId) {
            self.moveDown(collId, rect.top + toHeight);
          }
        });
        self.unfill(rect.top, rect.left, rect.width, rect.height);
        self.fill(id, rect.top, rect.left, toWidth, toHeight);
      };

      p.moveDown = function(id, toRow) {
        var self = this;
        var rect = self.getElementRect(id);
        self.unfill(rect.top, rect.left, rect.width, rect.height);
        var ids = this.getElementsInRect(toRow, rect.left, rect.width, rect.height);
        ids.forEach(function(id) {
          self.moveDown(id, toRow + rect.height);
        });
        this.fill(id, toRow, rect.left, rect.width, rect.height);
      };

      p.compact = function() {
        var self = this;
        var elements = this.getElements();
        elements.forEach(function(id) {
          var rect = self.getElementRect(id);
          var rowOffset = 1;
          var isSpaceAvailable = self.isSpaceAvailable(rect.top-rowOffset, rect.left, rect.width, 1);
          while(isSpaceAvailable) {
            rowOffset++;
            isSpaceAvailable = self.isSpaceAvailable(rect.top-rowOffset, rect.left, rect.width, 1);
            if(!isSpaceAvailable) {
              self.unfill(rect.top, rect.left, rect.width, rect.height);
              self.fill(id, rect.top-rowOffset+1, rect.left, rect.width, rect.height);
            }
          };
        });
      };

      p.getElementId = function(element) {
        return element.dataset.gridId;
      };

      p.registerElement = function(element) {
        var id = 'grid_' + this._counter++;
        element.dataset.gridId = id;
        return id;
      };

      p.getElementSize = function(id) {
        var pos = this.getElementPosition(id);
        if(!pos) {
          return {width: 1, height: 1};
        }
        var size = {width: 0, height: 0};
        var row = pos.top;
        while(!size.height) {
          if(id !== this.getElementInCell(row, pos.left)) {
            size.height = row-pos.top;
          }
          row++;
        }
        var column = pos.left;
        while(!size.width) {
          if(id !== this.getElementInCell(pos.top, column)) {
            size.width = column-pos.left;
          }
          column++;
        }
        return size;
      };

      p.getElementPosition = function(id) {
        var current;
        for(var top = 0, rows = this.rows; top < rows; ++top) {
          for(var left = 0, columns = this.columns; left < columns; ++left) {
            current =  this.getElementInCell(top, left);
            if(current === id) {
              return {top: top, left: left};
            }
          }
        }
      };

      p.getElementRect = function(id) {
        var size = this.getElementSize(id);
        var pos = this.getElementPosition(id);
        return {
          top: pos.top,
          left: pos.left,
          width: size.width,
          height: size.height
        };
      };

      p.getElements = function() {
        var cells = this._cells;
        return Object.keys(cells).reduce(function(arr, cellId) {
          var id = cells[cellId];
          if(arr.indexOf(id) === -1) {
            arr.push(id);
          }
          return arr;
        }, []);
      };

      // Polymer element

      Polymer('ab-grid', {

        columns: 10,
        rows: 10,
        gutter: 15,

        _resizeZoneSize: 20,
        _resizedElem: null,

        domReady: function() {
          this._layout = new GridLayout(this.columns, this.rows);
          this._initializeGrid();
          this.render();
        },

        _initializeGrid: function() {
          var self = this;
          var elements = self.$.content.getDistributedNodes();
          slice.call(elements).forEach(function(element) {
            self._layout.insert(element, {
              top: +element.dataset.gridTop,
              left: +element.dataset.gridLeft,
              width: +element.dataset.gridWidth,
              height: +element.dataset.gridHeight
            });
          });
        },

        getCellSize: function() {
          return {
            width: (this.clientWidth - (this.gutter * (this.columns-1)))/this.columns,
            height: (this.clientHeight - (this.gutter * (this.rows-1)))/this.rows,
          };
        },

        getRoundedSize: function(el) {
          var rect = el.getBoundingClientRect();
          var cellSize = this.getCellSize();
          var hRatio = rect.width/cellSize.width;
          var hFloor = hRatio >> 0;
          var hOffset = ((hRatio - hFloor > 0.10) ?  1 : 0);
          var vRatio = rect.height/cellSize.height;
          var vFloor = vRatio >> 0;
          var vOffset = ((vRatio - vFloor > 0.10) ?  1 : 0);
          return {
            width: (hFloor + hOffset) * cellSize.width + (hOffset ?  hFloor : hFloor-1) * this.gutter,
            height: (vFloor + vOffset) * cellSize.height + (vOffset ?  vFloor : vFloor-1) * this.gutter,
          };
        },

        render: function() {

          var self = this;
          var cellSize = this.getCellSize();
          var elements = self.$.content.getDistributedNodes();

          slice.call(elements).forEach(function(el) {

            var id = self._layout.getElementId(el);
            var rect = self._layout.getElementRect(id);

            _translate(
              el,
              rect.left * cellSize.width + rect.left * self.gutter,
              rect.top * cellSize.height + rect.top * self.gutter
            );

            el.draggable = true;

            // Update data attributes
            el.dataset.gridWidth = rect.width;
            el.dataset.gridHeight = rect.height;
            el.dataset.gridLeft = rect.left;
            el.dataset.gridTop = rect.top;

            // Update size and position
            el.style.height = rect.height * cellSize.height + ((rect.height-1) * self.gutter);
            el.style.width = rect.width * cellSize.width + ((rect.width-1) * self.gutter);
            el.style.minWidth = cellSize.width;
            el.style.minHeight = cellSize.height;
            el.innerHTML = el.dataset.gridId;

          });
        },

        _inResizeZone: function(el, x, y) {
          var width = el.clientWidth;
          var height = el.clientHeight;
          return x >= width - this._resizeZoneSize && y >= height - this._resizeZoneSize;
        },

        _getRelMousePos: function(evt) {
          var rect = evt.target.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
          };
        },

        _startResizing: function(evt) {
          var pos = this._getRelMousePos(evt);
          if(this._resizedElem || this._inResizeZone(evt.target, pos.x, pos.y)) {
            this._resizedElem = evt.target;
            this._updatePlaceholder(this._resizedElem);
            this._togglePlaceholder(true);
            evt.preventDefault();
          }
        },

        _stopResizing: function() {
          var el = this._resizedElem;
          if(el) {
            var roundedSize = this.getRoundedSize(el);
            el.style.width = roundedSize.width;
            el.style.height = roundedSize.height;
            this._togglePlaceholder(false);
          }
          this._resizedElem = null;
        },

        _resize: function(evt) {
          var el = this._resizedElem;
          if(el) {

            var left = +el.dataset.gridLeft;
            var top = +el.dataset.gridTop;

            var roundedSize = this.getRoundedSize(el);
            var cellSize = this.getCellSize();
            var width = roundedSize.width / cellSize.width >> 0;
            var height = roundedSize.height / cellSize.height >> 0;
            var id = this._layout.getElementId(el);

            this._layout.resize(id, width, height);
            this._layout.compact();

            this.render();

            var rect = el.getBoundingClientRect();
            el.style.width = evt.pageX - rect.left - window.scrollX;
            el.style.height = evt.pageY - rect.top - window.scrollY;

            this._updatePlaceholder(el);

            evt.preventDefault();
          }
        },

        _togglePlaceholder: function(isVisible) {
          this.$.placeholder.style.display = isVisible ? 'block' : 'none';
        },

        _updatePlaceholder: function(el) {
          var placeholder = this.$.placeholder;
          var cellSize = this.getCellSize();
          var roundedSize = this.getRoundedSize(el);
          var left = +el.dataset.gridLeft || 0;
          var top = +el.dataset.gridTop || 0;
          placeholder.style.minWidth = cellSize.width;
          placeholder.style.minHeight = cellSize.height;
          placeholder.style.height = roundedSize.height;
          placeholder.style.width = roundedSize.width;
          _translate(
            placeholder,
            left * cellSize.width + left * this.gutter,
            top * cellSize.height + top * this.gutter
          );
        }

    });
  }());
  </script>
</polymer-element>